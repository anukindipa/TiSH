#include "shell.h"

//////////////////////////////////////////////////////////////////////////////
// check if command exists in any of the PATH directories
//   - depends on command_exists_in_dir (see below)
//   - PATH_dirs: set of directory strings from PATH env variable
//        - generated by _PATH_dirs() (see below)
//////////////////////////////////////////////////////////////////////////////
std::filesystem::path command_exists_in_PATH(
    const std::string& command, const std::set<std::string>& PATH_dirs) {
    for (const auto& dir : PATH_dirs) {
        std::filesystem::path result =
            command_exists_in_dir(command, std::filesystem::path(dir));
        if (!result.empty()) {
            return result;
        }
    }

    // return empty path if not found
    return std::filesystem::path();
}

//////////////////////////////////////////////////////////////////////////////
// check if command exists in given directory
//////////////////////////////////////////////////////////////////////////////
std::filesystem::path command_exists_in_dir(const std::string& command,
                                            const std::filesystem::path& dir) {
    std::filesystem::path full_path = std::filesystem::path(dir) / command;
    if (std::filesystem::exists(full_path) &&
        std::filesystem::is_regular_file(full_path)) {
        // check if owner has execute permission
        if ((std::filesystem::status(full_path).permissions() &
             std::filesystem::perms::owner_exec) !=
            std::filesystem::perms::none) {
            return full_path;
        }
    }

    // return empty path if not found
    return std::filesystem::path();
}

//////////////////////////////////////////////////////////////////////////////
// stores all directories in PATH environment variable.
//   - returns set of directory strings and empty set if PATH is not set.
//////////////////////////////////////////////////////////////////////////////
std::set<std::string> _PATH_dirs() {
    std::set<std::string> paths;
    std::string env_p = std::getenv("PATH");
    if (!env_p.empty()) {
        // temporary stringstream to split PATH by ':'
        std::stringstream ss(env_p);
        std::string s;

        // split and store
        while (std::getline(ss, s, ':')) {
            paths.insert(s);
        }
    }
    return paths;
}

//////////////////////////////////////////////////////////////////////////////
// DO NOT RUN THIS
// This is very slow in wsl
//    because IO operations for windows filesystem are slow
//    and System32 has a lot of files
//    might work better on native linux
//////////////////////////////////////////////////////////////////////////////
std::set<std::filesystem::path> get_path_commands() {
    std::set<std::filesystem::path> path_commands;

    // get PATH env var which contains directories separated by ':'
    std::string env_p = std::getenv("PATH");

    if (!env_p.empty()) {
        // store all paths from PATH variable
        std::vector<std::string> paths;

        // temporary stringstream to split PATH by ':'
        std::stringstream ss(env_p);
        std::string s;

        // split and store
        while (std::getline(ss, s, ':')) {
            paths.push_back(s);
        }

        // check each directory for executable files
        for (const auto& p : paths) {
            // check if directory exists
            if (!std::filesystem::exists(p) ||
                !std::filesystem::is_directory(p)) {
                continue;
            }
            for (const auto& entry : std::filesystem::directory_iterator(p)) {
                // store executable files if owner has execute permission
                std::filesystem::path file_path = entry.path();
                if ((std::filesystem::status(file_path).permissions() &
                     std::filesystem::perms::owner_exec) !=
                    std::filesystem::perms::none) {
                    path_commands.insert(file_path);
                }
            }
        }
    }
    return path_commands;
}