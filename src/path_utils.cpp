#include "shell.h"

//////////////////////////////////////////////////////////////////////////////
// check if command exists in any of the PATH directories
//   - depends on command_exists_in_dir (see below)
//   - PATH_dirs: set of directory strings from PATH env variable
//        - generated by _PATH_dirs() (see below)
//////////////////////////////////////////////////////////////////////////////
fs::path command_exists_in_PATH(const std::string& command,
                                const std::vector<std::string>& PATH_dirs) {
    for (const auto& dir : PATH_dirs) {
        fs::path result = command_exists_in_dir(command, fs::path(dir));
        if (!result.empty()) {
            return result;
        }
    }

    // return empty path if not found
    return fs::path();
}

//////////////////////////////////////////////////////////////////////////////
// check if command exists in given directory
//////////////////////////////////////////////////////////////////////////////
fs::path command_exists_in_dir(const std::string& command,
                               const fs::path& dir) {
    fs::path full_path = fs::path(dir) / command;
    if (fs::exists(full_path) && fs::is_regular_file(full_path)) {
        // check if owner has execute permission
        if ((fs::status(full_path).permissions() & fs::perms::owner_exec) !=
            fs::perms::none) {
            return full_path;
        }
    }

    // return empty path if not found
    return fs::path();
}

//////////////////////////////////////////////////////////////////////////////
// stores all directories in PATH environment variable.
//   - returns set of directory strings and empty set if PATH is not set.
//////////////////////////////////////////////////////////////////////////////
std::vector<std::string> _PATH_dirs() {
    std::vector<std::string> paths;
    std::string env_p = std::getenv("PATH");
    if (!env_p.empty()) {
        // temporary stringstream to split PATH by ':'
        std::stringstream ss(env_p);
        std::string s;

        // split and store
        while (std::getline(ss, s, ':')) {
            paths.push_back(s);
        }
    }
    return paths;
}

//////////////////////////////////////////////////////////////////////////////
// DO NOT RUN THIS
// This is very slow in wsl
//    because IO operations for windows filesystem are slow
//    and System32 has a lot of files
//    might work better on native linux
//////////////////////////////////////////////////////////////////////////////
std::vector<fs::path> get_path_commands() {
    std::vector<fs::path> path_commands;

    // get PATH env var which contains directories separated by ':'
    std::string env_p = std::getenv("PATH");

    if (!env_p.empty()) {
        // store all paths from PATH variable
        std::vector<std::string> paths;

        // temporary stringstream to split PATH by ':'
        std::stringstream ss(env_p);
        std::string s;

        // split and store
        while (std::getline(ss, s, ':')) {
            paths.push_back(s);
        }

        // check each directory for executable files
        for (const auto& p : paths) {
            // check if directory exists
            if (!fs::exists(p) || !fs::is_directory(p)) {
                continue;
            }
            for (const auto& entry : fs::directory_iterator(p)) {
                // store executable files if owner has execute permission
                fs::path file_path = entry.path();
                if ((fs::status(file_path).permissions() &
                     fs::perms::owner_exec) != fs::perms::none) {
                    path_commands.push_back(file_path);
                }
            }
        }
    }
    return path_commands;
}